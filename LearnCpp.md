# C++学习笔记

## C++头文件命名约定

* C++新式风格：没有扩展名(例如iostream)
* 转换后的C：加上前缀c，没有扩展名(例如cmath)

---

## C++通用字符名

* ISO10646
  * 以\u或\U开头；\u后面是8个16进制位，\U后面是16个16进制位

---

## C++强制类型转换

* 通用格式
  * C风格:(typename) value
  * C++风格:typename (value)

* 强制类型转换运算符
  * `static_cast<typename> (value)`

---

## C++11数组初始化

* 初始化数组时可省略'='
  * `char arr[5] {1, 2, 3, 4, 5};`

* 可不在大括号内包含任何东西，这将把所有元素设为0:
  * `unsigned int arr[5] {};`

* 列表初始化不允许缩窄转换
  * `long num[] = {1, 2, 3.33};//not allowed`

---

## C++字符串输入

* cin.getline()

  * getline()函数读取整行，通过换行符确定输入结尾。

  * getline()有两个参数，第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用来存储自动在结尾处添加的空字符。

  * getline()成员函数在读取指定数目字符或遇到换行符时停止读取
    `//cin.getline(name, 20);`

  * getline()到达换行符时将停止输入并丢弃换行符

* cin.get()

  * 与getline类似，都接受相同的参数，解释参数的方式也相同，并且都读到行尾。

  * get不再读取并丢弃换行符，而是将其留在输入队列中

---

## new和delete

* 使用new来分配内存: `int* pn = new int;`

* 使用delete来释放内存: `delete pn;`

* 使用new创建动态数组: `int* arr = new int[10];`

* 使用new和delete时应遵守以下规则

  * 不要使用delete来释放不是new分配的内存

  * 不要使用delete释放同一个内存块两次

  * 如果使用new []为数组分配内存，则应使用delete []来释放

  * 对空指针使用delete是安全的
  
### 尽可能地使用const

将指针参数声明为指向常量数据的指针有两条理由:

* 这样可以避免由于无意间修改数据而导致的编程错误
* 使用const使得函数能够处理const和非const实参,否则将只能接受非const数据.如果条件允许,则应将指针实参声明为指向const的指针.

---

## 自动存储，静态存储，动态存储

1. 自动存储

    * 在函数内部定义的常规变量使用自动存哦戳空间，被成为自动变量(automatic variable)，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡

2. 静态存储

    * 静态存储是整个程序执行期间都存在的存储方式

    * 使变量成为静态的方式有两种:一种是在函数外面定义它，一种是在声明变量时使用关键字static

3. 动态存储

    * new和delete运算符操作的存储空间

---

## 函数

### 函数默认参数

在C++中,函数的形参列表中的形参是可以有默认值的.
语法:`返回值类型 函数名 (参数 = 默认值) {}`

**示例:**

``` cpp
int func(int a, int b = 10, int c = 10) {
  return a + b + c;
}

//1.如果某个位置参数有默认值,那么从这个位置往后,从左向右,必须都要有默认值
//2.如果函数声明有默认值,函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
  return a + b;
}

int main(void) {
  cout << func(10) << endl;

  return 0;
}
```

### 函数占位参数

C++中函数的形参列表里可以有占位参数,用来占位,调用函数时必须填补该位置

**语法:** `返回值类型 函数名 (数据类型) {}`

**示例:**

``` cpp
//函数占位参数,占位参数也可以有默认参数
void func(int a, int) {
  cout << "this is func" << endl;
}

int main(void) {
  func(10, 10)  //占位参数必须填补

  return 0;
}
```

### 函数重载

**作用:** 函数名可以相同,提高复用性

**函数重载满足条件:**

* 同一个作用域下
* 函数名称相同
* 函数参数**类型不同**或者**个数不同**或者**顺序不同**

**注意:** 函数的返回值不可以作为函数重载的条件

**示例:**

``` cpp
//函数重载需要函数都在同一个作用域下
void func() {
  cout << "func的调用!" << endl;
}

void func(int a) {
  cout << "func的调用!" << endl;
}

void func(int a, double b) {
  cout << "func的调用!" << endl;
}
```

#### 函数重载注意事项

* 引用作为重载条件
* 函数重载碰到函数默认参数

**示例:**

``` cpp
//函数重载注意事项
//1.引用作为重载条件

void func(int &a) {
  cout << "func (int &a) 调用" << endl;
}

void func(const int &a) {
  cout << "func (const int &a) 调用" << endl;
}

//2.函数重载碰到默认参数
void func2(int a) {
  cout << "func2 (int a) 调用" << endl;
}

void func2(int a, int b = 10) {
  cout << "func2 (int a, int b) 调用" << endl;
}

int main(void) {
  int a = 10;
  
  func(a);  //会使用第一个func
  func(10)  //会使用第二个func

  func2(10);  //不可以,当函数重载碰到默认参数,会出现二义性,尽量避免这种情况
  func2(10, 20);  //可以,将使用第二个func2

  return 0;
}
```

### C++内联函数

#### 为什么使用内联函数

* 内联函数最初的定义:代替部分#define宏定义
* 使用使用内联函数代替普通函数的目的:提高程序的运行效率

##### 1.为什么要代替部分宏定义

* 宏是预处理指令,在预处理的时候把所有的宏名用宏体来替换,内联函数是函数,在编译阶段把所有调用内联函数的地方把内联函数插入.
* 宏没有类型检查,无论对错都直接替换,而内联函数在编译时进行安全检查.
* 对于C++而言,使用宏代码还有另一种缺点:无法操作类的私有数据成员.

##### 2.普通函数频繁调用消耗栈空间

函数是一个可以频繁使用的代码块,CPU会一条一条地执行其中的代码.CPU在执行主调函数代码时如果遇到了被调函数,主调函数就会暂停,CPU转而执行被调函数的代码,被调函数执行完毕后再回到主调函数,主调函数根据刚才的状态继续执行.

一个C/C++程序的执行过程可以认为是多个函数之间相互调用的过程,他们形成了一个简单或复杂的调用链条,这个链条的起点是main(),终点也是main().当main()调用完了所有的函数,他会返回一个值(例如return 0)来结束自己的生命,从而结束整个程序.

栈空间就是指放置模式的局部数据也就是函数内数据的内存空间,在系统下,栈空间是有限的,频繁大量地使用就会造成因栈空间不足而导致的问题,函数的死循环递归调用的结果就是栈内存空间枯竭.

如果函数体的代码比较多,需要较长的执行时间,那么函数调用机制占用的时间可以忽略,如果函数语句只有一两条,那么大部分时间都会花费在函数调用机制上,这种时间开销就不容忽视.

#### 使用内联函数

要使用这项特性,必须采取下述措施之一:

* 在函数声明前加上关键字inline.
* 在函数定义前加上关键字inline.

```   cpp
inline int sum(int a, int b) {
  return (a + b);
}
```

通常的做法是省略原型,将整个定义(即函数头和所有函数代码)放在本应该提供原型的地方.
程序员请求将函数作为内联函数时,编译器并不一定会满足这种要求.他可能认为该函数过大或注意到函数调用了自己(内联函数不能递归),因此不将其作为内联函数,而有些编译器没有启用或实现这种特性.

#### 内联的局限性

1. 内联是以代码膨胀为代价,仅仅省去了函数调用的开销,从而提高函数的运行效率.如果执行函数体内代码的时间,相比于函数调用的开销大,那么效率的收获会很少.(一般情况下,在函数频繁调用且函数内部代码很少的情况下使用内联)
2. 每一处内联函数的调用都要复制代码,这将程序的总代码量增大,消耗更多内存空间.
3. 类的构造函数和析构函数容易让人误解成使用内联更有效.要当心构造函数和析构函数可能会隐藏一些行为,如"偷偷地"执行了基类或成员对象的构造函数和析构函数.所以不要随便地将构造函数和析构函数的定义放在类声明中.
4. 一个好的编译器会根据函数的定义,自动取消不值得的内联(这进一步说明了inline不应该出现在函数的声明).对函数inline声明只是程序员对编译器提出的一个建议,而不是强制性的,并非一经指定为inline编译器就必须这样做.编译器有自己的判断能力,它会根据具体情况决定是否这样做.具体是否会被编译器优化为内联也要看优化级别.有些函数即使声明为内联也不一定会被编译器内联,比如虚函数和递归函数就不会被正常内联.通常,递归函数不应该声明为内联函数.(递归调用堆栈并不像循环那么简单,比如递归层数在编译时可能是未知的,大部分编译器都不支持内联递归函数).将内联函数放在头文件里实现是合适的,省却你为每一个文件实现一次的麻烦.如果每个文件都实现一次该内联函数的话,最好保证每个定义都是一样的,否则将会引起未定义行为.

---

## 引用

**作用:**给变量起别名

**语法:**`数据类型 &别名 = 原名`

``` cpp
int a = 233;
int &b = a;
```

### 引用的注意事项

* 引用必须初始化
* 引用在初始化后,不可以改变
* 一个变量可以有多个引用
* 一个引用可以继续有引用
* 可以对任何类型做引用
* 引用不是定义一个新的变量,而是给已经存在的变量取一个别名,编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.

### 引用做函数参数

**作用:** 函数传参时,可以利用引用的技术让形参修饰实参.
**优点:** 可以简化指针修改实参.

``` cpp
//1.值传递
void mySwap1(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}

//2.地址传递
void mySwap2(int* a, int* b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

//3.引用传递
void mySwap3(int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}
```

### 引用做函数返回值

作用:引用是可以作为函数的返回值存在的

注意:不要返回局部变量引用
用法:函数调用作为左值

**示例:**

``` cpp
//返回局部变量引用
int& test01() {
  int a = 10; //局部变量
  return a;
}

//返回静态变量引用
int& test02() {
  static int a = 20;
  return a;
}
```

### 引用的本质

本质: **引用的本质在C++内部实现是一个指针常量.**

``` cpp
//发现是引用,转换为 int* const ref = &a;
void func(int& ref) {
  ref = 100; //ref是引用,转换为*ref = 100
}

int main(void) {
  int a = 10;

  //自动转换为 int* const ref = &a; 指针常量是指针指向不可改变,也说明为什么引用不可改变
  int& ref = a; //内部发现ref是引用,自动帮我们转换为: *ref = 20;

  cout << "a:" << a << endl;
  cout << "ref:" << ref << endl;

  func(a);
  return 0;
}
```

### 常量引用

**作用:**常量引用主要用来修饰形参,防止误操作

在函数形参列表中,可以加**const修饰形参**,防止形参改变实参

**示例:**

``` cpp
void showValue(const int& v) {
  //v += 10;
  cout << v << endl;
}

int main(void) {
  //int& ref = 10; 应用本身需要一个合法的内存空间,因此这行错误
  //加入const就可以了,编译器优化代码, int temp = 10; const int& ref = temp;
}
```

---

## 类和对象

C++面向对象的三大特向为: **封装,继承,多态**

C++认为万物皆对象,对象上具有其属性和行为

### 封装

#### 封装的意义

封装是C++面向对象三大特性之一

封装的意义:

* 将属性和行为作为一个整体,表现生活中的事物
* 将属性和行为加以权限控制

在设计类的时候,属性和行为写在一起,表现事物

**语法:** `class 类名{访问权限 : 属性 / 行为};`

类在设计时,可以把属性和行为放在不同的权限下,加以控制

访问权限有三种:

1. public 公共权限,成员在类内外都可以访问;任何一种继承,子类都可以访问父类的公共成员.
2. protected 保护权限,成员在类内可访问;类外不可访问,任何一种继承,子类都可以访问父类的保护成员.
3. private 私有权限,类内可以访问,类外不可访问;任何一种继承,子类都**不可以**访问父类的私有成员.

### struct和class的区别

在C++中struct和class唯一的区别是默认访问权限不同

* struct默认权限为公有
* calss默认权限为私有
