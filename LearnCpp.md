# C++学习笔记

## C++头文件命名约定

* C++新式风格：没有扩展名(例如iostream)
* 转换后的C：加上前缀c，没有扩展名(例如cmath)

---

## C++通用字符名

* ISO10646
  * 以\u或\U开头；\u后面是8个16进制位，\U后面是16个16进制位

---

## C++强制类型转换

* 通用格式
  * C风格:(typename) value
  * C++风格:typename (value)

* 强制类型转换运算符
  * `static_cast<typename> (value)`

---

## C++11数组初始化

* 初始化数组时可省略'='
  * `char arr[5] {1, 2, 3, 4, 5};`

* 可不在大括号内包含任何东西，这将把所有元素设为0:
  * `unsigned int arr[5] {};`

* 列表初始化不允许缩窄转换
  * `long num[] = {1, 2, 3.33};//not allowed`

---

## C++字符串输入

* cin.getline()

  * getline()函数读取整行，通过换行符确定输入结尾。

  * getline()有两个参数，第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用来存储自动在结尾处添加的空字符。

  * getline()成员函数在读取指定数目字符或遇到换行符时停止读取
    `//cin.getline(name, 20);`

  * getline()到达换行符时将停止输入并丢弃换行符

* cin.get()

  * 与getline类似，都接受相同的参数，解释参数的方式也相同，并且都读到行尾。

  * get不再读取并丢弃换行符，而是将其留在输入队列中

---

## new和delete

* 使用new来分配内存: `int* pn = new int;`

* 使用delete来释放内存: `delete pn;`

* 使用new创建动态数组: `int* arr = new int[10];`

* 使用new和delete时应遵守以下规则

  * 不要使用delete来释放不是new分配的内存

  * 不要使用delete释放同一个内存块两次

  * 如果使用new []为数组分配内存，则应使用delete []来释放

  * 对空指针使用delete是安全的
  
### 尽可能地使用const

将指针参数声明为指向常量数据的指针有两条理由:

* 这样可以避免由于无意间修改数据而导致的编程错误
* 使用const使得函数能够处理const和非const实参,否则将只能接受非const数据.如果条件允许,则应将指针实参声明为指向const的指针.

---

## 自动存储，静态存储，动态存储

1. 自动存储

    * 在函数内部定义的常规变量使用自动存哦戳空间，被成为自动变量(automatic variable)，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡

2. 静态存储

    * 静态存储是整个程序执行期间都存在的存储方式

    * 使变量成为静态的方式有两种:一种是在函数外面定义它，一种是在声明变量时使用关键字static

3. 动态存储

    * new和delete运算符操作的存储空间

---

## 函数

### 函数默认参数

在C++中,函数的形参列表中的形参是可以有默认值的.
语法:`返回值类型 函数名 (参数 = 默认值) {}`

**示例:**

``` cpp
int func(int a, int b = 10, int c = 10) {
  return a + b + c;
}

//1.如果某个位置参数有默认值,那么从这个位置往后,从左向右,必须都要有默认值
//2.如果函数声明有默认值,函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
  return a + b;
}

int main(void) {
  cout << func(10) << endl;

  return 0;
}
```

### 函数占位参数

C++中函数的形参列表里可以有占位参数,用来占位,调用函数时必须填补该位置

**语法:** `返回值类型 函数名 (数据类型) {}`

**示例:**

``` cpp
//函数占位参数,占位参数也可以有默认参数
void func(int a, int) {
  cout << "this is func" << endl;
}

int main(void) {
  func(10, 10)  //占位参数必须填补

  return 0;
}
```

### 函数重载

**作用:** 函数名可以相同,提高复用性

**函数重载满足条件:**

* 同一个作用域下
* 函数名称相同
* 函数参数**类型不同**或者**个数不同**或者**顺序不同**

**注意:** 函数的返回值不可以作为函数重载的条件

**示例:**

``` cpp
//函数重载需要函数都在同一个作用域下
void func() {
  cout << "func的调用!" << endl;
}

void func(int a) {
  cout << "func的调用!" << endl;
}

void func(int a, double b) {
  cout << "func的调用!" << endl;
}
```

#### 函数重载注意事项

* 引用作为重载条件
* 函数重载碰到函数默认参数

**示例:**

``` cpp
//函数重载注意事项
//1.引用作为重载条件

void func(int &a) {
  cout << "func (int &a) 调用" << endl;
}

void func(const int &a) {
  cout << "func (const int &a) 调用" << endl;
}

//2.函数重载碰到默认参数
void func2(int a) {
  cout << "func2 (int a) 调用" << endl;
}

void func2(int a, int b = 10) {
  cout << "func2 (int a, int b) 调用" << endl;
}

int main(void) {
  int a = 10;
  
  func(a);  //会使用第一个func
  func(10)  //会使用第二个func

  func2(10);  //不可以,当函数重载碰到默认参数,会出现二义性,尽量避免这种情况
  func2(10, 20);  //可以,将使用第二个func2

  return 0;
}
```

### C++内联函数

#### 为什么使用内联函数

* 内联函数最初的定义:代替部分#define宏定义
* 使用使用内联函数代替普通函数的目的:提高程序的运行效率

##### 1.为什么要代替部分宏定义

* 宏是预处理指令,在预处理的时候把所有的宏名用宏体来替换,内联函数是函数,在编译阶段把所有调用内联函数的地方把内联函数插入.
* 宏没有类型检查,无论对错都直接替换,而内联函数在编译时进行安全检查.
* 对于C++而言,使用宏代码还有另一种缺点:无法操作类的私有数据成员.

##### 2.普通函数频繁调用消耗栈空间

函数是一个可以频繁使用的代码块,CPU会一条一条地执行其中的代码.CPU在执行主调函数代码时如果遇到了被调函数,主调函数就会暂停,CPU转而执行被调函数的代码,被调函数执行完毕后再回到主调函数,主调函数根据刚才的状态继续执行.

一个C/C++程序的执行过程可以认为是多个函数之间相互调用的过程,他们形成了一个简单或复杂的调用链条,这个链条的起点是main(),终点也是main().当main()调用完了所有的函数,他会返回一个值(例如return 0)来结束自己的生命,从而结束整个程序.

栈空间就是指放置模式的局部数据也就是函数内数据的内存空间,在系统下,栈空间是有限的,频繁大量地使用就会造成因栈空间不足而导致的问题,函数的死循环递归调用的结果就是栈内存空间枯竭.

如果函数体的代码比较多,需要较长的执行时间,那么函数调用机制占用的时间可以忽略,如果函数语句只有一两条,那么大部分时间都会花费在函数调用机制上,这种时间开销就不容忽视.

#### 使用内联函数

要使用这项特性,必须采取下述措施之一:

* 在函数声明前加上关键字inline.
* 在函数定义前加上关键字inline.

```   cpp
inline int sum(int a, int b) {
  return (a + b);
}
```

通常的做法是省略原型,将整个定义(即函数头和所有函数代码)放在本应该提供原型的地方.
程序员请求将函数作为内联函数时,编译器并不一定会满足这种要求.他可能认为该函数过大或注意到函数调用了自己(内联函数不能递归),因此不将其作为内联函数,而有些编译器没有启用或实现这种特性.

#### 内联的局限性

1. 内联是以代码膨胀为代价,仅仅省去了函数调用的开销,从而提高函数的运行效率.如果执行函数体内代码的时间,相比于函数调用的开销大,那么效率的收获会很少.(一般情况下,在函数频繁调用且函数内部代码很少的情况下使用内联)
2. 每一处内联函数的调用都要复制代码,这将程序的总代码量增大,消耗更多内存空间.
3. 类的构造函数和析构函数容易让人误解成使用内联更有效.要当心构造函数和析构函数可能会隐藏一些行为,如"偷偷地"执行了基类或成员对象的构造函数和析构函数.所以不要随便地将构造函数和析构函数的定义放在类声明中.
4. 一个好的编译器会根据函数的定义,自动取消不值得的内联(这进一步说明了inline不应该出现在函数的声明).对函数inline声明只是程序员对编译器提出的一个建议,而不是强制性的,并非一经指定为inline编译器就必须这样做.编译器有自己的判断能力,它会根据具体情况决定是否这样做.具体是否会被编译器优化为内联也要看优化级别.有些函数即使声明为内联也不一定会被编译器内联,比如虚函数和递归函数就不会被正常内联.通常,递归函数不应该声明为内联函数.(递归调用堆栈并不像循环那么简单,比如递归层数在编译时可能是未知的,大部分编译器都不支持内联递归函数).将内联函数放在头文件里实现是合适的,省却你为每一个文件实现一次的麻烦.如果每个文件都实现一次该内联函数的话,最好保证每个定义都是一样的,否则将会引起未定义行为.

---

## 引用

**作用:**给变量起别名

**语法:**`数据类型 &别名 = 原名`

``` cpp
int a = 233;
int &b = a;
```

### 引用的注意事项

* 引用必须初始化
* 引用在初始化后,不可以改变
* 一个变量可以有多个引用
* 一个引用可以继续有引用
* 可以对任何类型做引用
* 引用不是定义一个新的变量,而是给已经存在的变量取一个别名,编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.

### 引用做函数参数

**作用:** 函数传参时,可以利用引用的技术让形参修饰实参.
**优点:** 可以简化指针修改实参.

``` cpp
//1.值传递
void mySwap1(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}

//2.地址传递
void mySwap2(int* a, int* b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

//3.引用传递
void mySwap3(int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}
```

### 引用做函数返回值

作用:引用是可以作为函数的返回值存在的

注意:不要返回局部变量引用
用法:函数调用作为左值

**示例:**

``` cpp
//返回局部变量引用
int& test01() {
  int a = 10; //局部变量
  return a;
}

//返回静态变量引用
int& test02() {
  static int a = 20;
  return a;
}
```

### 引用的本质

本质: **引用的本质在C++内部实现是一个指针常量.**

``` cpp
//发现是引用,转换为 int* const ref = &a;
void func(int& ref) {
  ref = 100; //ref是引用,转换为*ref = 100
}

int main(void) {
  int a = 10;

  //自动转换为 int* const ref = &a; 指针常量是指针指向不可改变,也说明为什么引用不可改变
  int& ref = a; //内部发现ref是引用,自动帮我们转换为: *ref = 20;

  cout << "a:" << a << endl;
  cout << "ref:" << ref << endl;

  func(a);
  return 0;
}
```

### 常量引用

**作用:** 常量引用主要用来修饰形参,防止误操作

在函数形参列表中,可以加**const修饰形参**,防止形参改变实参

**示例:**

``` cpp
void showValue(const int& v) {
  //v += 10;
  cout << v << endl;
}

int main(void) {
  //int& ref = 10; 应用本身需要一个合法的内存空间,因此这行错误
  //加入const就可以了,编译器优化代码, int temp = 10; const int& ref = temp;
}
```

---

## 类和对象

C++面向对象的三大特向为: **封装,继承,多态**

C++认为万物皆对象,对象上具有其属性和行为

### 封装

#### 封装的意义

封装是C++面向对象三大特性之一

封装的意义:

* 将属性和行为作为一个整体,表现生活中的事物
* 将属性和行为加以权限控制

在设计类的时候,属性和行为写在一起,表现事物

**语法:** `class 类名{访问权限 : 属性 / 行为};`

类在设计时,可以把属性和行为放在不同的权限下,加以控制

访问权限有三种:

1. public 公共权限,成员在类内外都可以访问;任何一种继承,子类都可以访问父类的公共成员.
2. protected 保护权限,成员在类内可访问;类外不可访问,任何一种继承,子类都可以访问父类的保护成员.
3. private 私有权限,类内可以访问,类外不可访问;任何一种继承,子类都**不可以**访问父类的私有成员.

#### struct和class的区别

在C++中struct和class唯一的区别是默认访问权限不同

* struct默认权限为公有
* calss默认权限为私有

#### 将属性成员设置为私有

**优点1:**将所有成员属性设置为私有,可以自己控制读写权限.
**优点2:**对于写权限,我们可以检测数据的有效性.

示例:

``` cpp
using namespace std;

class Person {
  public:

    void setName(string name) {
      m_Name = name;
    }
    string getName() {
      return m_Name;
    }

  private:

    string m_Name;    
}
```

### 对象的初始化和清理

* 生活中我们买的电子产品都基本会有出厂设置,在某一天我们不用时也会删除一些自己的信息数据保证安全.
* C++中的面向对象来源于生活,每个对象也都会有初始设置以及对象销毁前的清理数据设置.

#### 构造函数与析构函数

对象的**初始化和清理**也是两个重要的安全问题

* 一个对象或者变量没有初始状态,对其使用的后果是未知.
* 同样使用完一个变量或对象,没有及时清理,也会造成一定的安全问题.

C++利用了**构造函数和析构函数**解决上述问题,这两个函数会被编译器自动调用,完成对象初始化和清理工作.
对象的初始化和清理工作是编译器强制要我们做的事情,因此如果**我们不提供构造和析构,编译器会提供**.
**编译器提供的构造函数和析构函数是空实现**.

* 构造函数:主要作用在于创建对象时为对象的成员属性赋值,构造函数由编译器自动调用,无需手动调用.
* 析构函数:主要作用在于对象**销毁前**系统自动调用,执行一些清理工作.

**构造函数语法:**`类名(){}`

1. 构造函数,没有返回值也不写void.
2. 函数名称与类名相同.
3. 构造函数可以有参数,因此可以发生重载.
4. 程序在调用对象时会自动调用构造,无需手动调用,而且只会调用一次.

**析构函数语法:**`~类名(){}`

1. 析构函数,没有返回值也不写void.
2. 函数名称与类名相同,在名称前加符号'~'.
3. 析构函数不允许有参数,因此不可以发生重载.
4. 程序在对象销毁前会自动调用析构,无需手动调用,而且只会调用一次.

#### 构造函数的分类及调用

两种分类方式:

1. 按参数分为:有参构造和无参构造.
2. 按类型分为:普通构造和拷贝构造.

三种调用方式:

1. 括号法
2. 显示法
3. 隐式转换法

C++中的构造函数可以分为5类:默认构造函数,普通构造函数,拷贝构造函数,转换构造函数,移动构造函数

##### 默认构造函数

不带参数的构造函数，通常用于初始化对象的默认状态.默认构造函数的原型为:

``` cpp
Student();//没有参数
Student(int num = 0, int age = 0);//所有参数均有默认值
```

###### 何时生成默认构造函数

当一个类**没有默认构造函数时**,如果满足以下四个条件之一,则编译器会为该类自动生成一个默认的构造函数:

1. 该类含有一个类类型(非内置类型)的成员变量,且该类型含有默认构造函数.
2. 该类型继承自含有默认构造函数的基类.
3. 该类继承或声明了虚函数.
4. 该类含有虚基类.

##### 普通构造函数

C++用于构建类的新对象时需要调用的函数

``` cpp
Student(int num, int age);//有参数
```

##### 拷贝构造函数

###### 何时生成拷贝构造函数

当一个类**没有拷贝构造函数时**,如果满足以下四个条件其中之一,则编译器会为该类自动生成一个默认的拷贝构造函数:

1. 该类含有一个类类型(非内置类型)的成员变量,且该类型含有拷贝构造函数.
2. 该类继承自含有拷贝构造函数的基类.
3. 该类继承或声明了虚函数.
4. 该类含有虚基类.

需要注意的是,默认的拷贝构造函数实现的是**浅拷贝**.

###### 拷贝构造函数调用的时机

拷贝构造函数在以下三种情况会被调用.

1. 当用一个对象去初始化另一个对象的时候,会引发拷贝构造函数被调用.例如,下面的两条语句都会引发拷贝构造函数的调用,用以初始化c2.

``` cpp
Complex c2(c1);
Complex c2 = c1;
```

这两条语句是等价的.

注意,**第二条语句是初始化语句,不是赋值语句**.赋值语句的等号左边是一个早已定义的变量,**赋值语句不会引发拷贝构造函数的调用**.例如:

``` cpp
Complex c1, c2;
c1=c2;
```

**这条语句不会引发拷贝构造函数的调用**,因为c1早已声明,已经初始化了.

2. 如果函数F的参数是类A的对象,那么当F被调用时,类A的拷贝构造函数将被调用.
也就是说,**作为形参的类A的对象,使用拷贝构造函数初始化的**,而且调用拷贝构造函数时的参数,就是调用函数时所给的实参.

``` cpp
#include <iostream>
using namespace std;
class A {
  public:
    A() {}
    A(A & a) {
      cout << "调用拷贝构造函数" << endl;
    }
};
void func(A a) {}
int main(void) {
  A a;
  func(a);
  return 0;
}
```

func函数的形参a在初始化时调用了拷贝构造函数.

以对象作为函数的形参,在函数被调用时,生成的形参要用于拷贝构造函数的初始化,这会带来时间上的开销.
如果用对象的引用而不是对象作为形参,就没有这个问题了.

3. 如果函数的返回值是类A的对象,则函数返回时,类A的拷贝构造参数将被调用.

``` cpp
#include <iostream>
using namespace std;
class A {
  public:
    int v;
    A(int n) {v = n;}
    A(const A & a) {
      v = a.v;
      cout << "调用拷贝构造函数" << endl;
    }
};
A func() {
  A a(4);
  return a;
}
int main(void) {
  cout << func().v << endl;
  return 0;
}
```

##### 转换构造函数

一个构造函数接收一个不同于其类型的形参,可以视为将其形参转换成类的一个对象.像这样的构造函数称为转换构造函数.
在C++**string类中可以找到使用转换构造函数的使用示例**.string类提供一个将C字符串转换为string的转换构造函数.

``` cpp
class string {
  //仅显示转换构造函数
  public:
    string(char *);//形参是其他类型变量,且只有一个形参.
};
```

##### 移动构造函数

移动构造函数用于从即将销毁的临时对象转移资源到新对象。它通常用于避免不必要的资源复制，并提高性能.

``` cpp
class Person {
  public:
    string name;
    int age;

    Person(Person&& other) {  //移动构造函数
      name = std::move(other.name);
      age = other.age;
      //将other的资源转移到this
    }
};

int main(void) {
  Person p1("bob", 25); //创建p1对象
  Person p2(std::move(p1)); //移动构造函数创建p2

  cout << p2.name << ", " << p2.age << endl; // 输出：Bob, 25
  cout << p1.name << ", " << p1.age << endl; // 输出：, 0 (p1 的资源已转移)

  return 0;
}
```

#### 深拷贝和浅拷贝

浅拷贝只复制指向某个对象的指针,而不复制对象本身,新旧对象还是共享同一块内存(分支).

1. 浅拷贝只是按位拷贝对象,他会创建一个对象,这个对象拥有着原始对象属性值的一份精确拷贝.
2. 如果属性是基本类型,拷贝的就是基本类型的值;如果属性是内存地址(引用类型),拷贝的就是内存地址,因此如果其中一个对象改变了这个地址,就会影响到另一个对象.

深拷贝会另外创建一个一模一样的对象,新对象跟原对象不共享内存,修改新对象不会修改旧对象(不是分支).

1. 拷贝第一层级的对象属性或数组元素
2. 递归拷贝所有层级的对象属性和数组元素
3. 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存.当对象和它所引用的对象一起拷贝即发生深拷贝.深拷贝相比于浅拷贝速度较慢并且花销较大.

#### C++初始化列表

C++提供了初始化列表语法,用来初始化属性

**语法:**``构造函数():属性1(值1),属性2(值2)...{}``

**示例:**

``` cpp
class Person {
  public:
  //传统方式初始化
  person(int a, int b, int c) {
    mA = a;
    mB = b;
    mC = c;
  }

  //初始化列表方式初始化
  Person(int a, int b, int c): mA(a), mB(b), mC(c) {}

  private:
  int mA;
  int mB;
  int mC;
}
```

### 对象作为类成员

C++类中的成员可以是另一个类的对象,我们称该成员为对象成员

例如:

``` cpp
class A {}
class B
{
  A a;
}
```

当其他类对象作为本类成员,构造时先构造类对象,再构造自身,析构的顺序与构造相反.

### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员

静态成员分为:

* 静态成员变量
  * 所有对象共享同一份数据
  * 在编译阶段分配内存
  * 类內声明,类外初始化
* 静态成员函数
  * 所有对象共享同一个函数
  * 静态成员函数只能访问静态成员变量

静态成员变量不属于某个对象,所有对象都共享同一份数据,因此静态成员变量有两种访问方式

1. 通过对象进行访问

``` cpp
Person P;
std::cout << p.m_A << std::endl;
```

2. 通过类名进行访问

``` cpp
std::cout << Person::m_A << std::endl;
```

类外访问不到私有静态成员变量

静态成员函数有两种访问方式

1. 通过对象访问

``` cpp
Person p;
p.func();
```

2. 通过类名访问

``` cpp
Person::func();
//类外访问不到私有静态成员函数
```

静态成员函数可以访问静态成员变量
静态成员函数不可以访问非静态成员变量,无法区分到底是哪个对象的变量
静态成员函数也有访问权限

### C++对象模型和this指针

* 在C++中,类内的成员变量和成员函数分开存储
* 只有非静态成员变量才属于类的对象
* 空对象占用内存空间为1字节
* C++编译器会给每个空对象分配一个字节空间,是为了区分空对象占用内存的位置,每个空对象也应该有一个独一无二的地址
* 注意：类的静态数据成员是静态存储，它是静态生存周期，**必须进行初始化**
* 注意：静态数据成员的初始化在类体外进行,前面不加static以免与一般静态变量或者对象混淆

#### this指针概念

每一个非静态成员函数只会诞生一份函数实例,也就是说多个同类型的对象会共用同一份代码
那么问题是:这一块代码是如何区分哪个对象调用了自己呢?

C++通过提供特殊的对象指针,this指针,解决上述问题.**this指针指向被调用的成员函数所属的对象**.

this指针是隐含在每一个非静态成员函数内的一种指针
this指针不需要定义,直接使用即可

this指针的用途:

* 当形参和成员变量同名时,可用this指针来区分
* 在类的非静态成员函数中返回对象本身,可使用return *this

#### 空指针访问成员函数

C++中空指针也是可以调用成员函数的,但是要注意有没有用到this指针
如果要用到this指针,需要加以判断保证代码的健壮性

#### const修饰成员函数

常函数:

* 成员函数后加const后我们称这个函数为**常函数**
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后,即使在常函数中也可以修改
* mutable修饰的变量即使在常函数中也可以修改

在成员函数后面加const,修饰的是this指针,让指针指向的值也不可以修改

常对象:

* 声明对象前加const称该对象为常对象
* 常对象不允许修改属性
* 常对象只能调用常函数,因为普通成员函数可以修改属性
* mutable修饰的变量在常对象下也可以修改

### 友元

在程序里,有些私有属性也想让类外特殊的一些函数进行访问,就需要用到友元函数

友元的目的就是让一个函数或者类访问另一个类中的私有成员

友元的关键字为friend

友元的三种实现:

* 全局函数做友元
* 类做友元
* 成员函数做友元

### 运算符重载

概念:对已有的运算符重新进行定义,赋予另一种功能,以适应不同的数据类型

#### 加号运算符重载

作用:实现两个自定义数据类型相加的运算

通过自己写全局函数,实现两个对象相加属性后返新的对象

``` cpp
Person PersonAddPerson(Person& p) {
  Person temp;
  temp.m_A = this->m_A + p.m_A;
  temp.m_B = this->m_B + p.m_Bz ;
  return temp;
}
```

编译器起了一个通用名称operator

通过成员函数重载'+'号

``` cpp
Person operator+ (Person &p) {
  Person temp;
  temp.m_A = this->m_A + p.m_A;
  temp.m_B = this->m_B + p.m_B;
  return temp;
}

Person p3 = p1.operator+(p2);
//可以简化为
Person p3 = p1 + p2;
```

总结1:对于内置的数据类型的表达式的运算符是不可更改的
总结2:不要滥用运算符重载

#### 左移运算符重载

作用:可以输出自定义数据类型

利用成员函数重载左移运算符可以实现`p.operator<<(cout)`简化版本`p << cout`

不会利用成员函数重载`<<`运算符,因为无法实现`cout`在左侧

#### 递增运算符重载

作用:通过重载递增运算符,实现自己的整形数据